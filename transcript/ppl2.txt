TRANSCRIPTOR: V.Srinivasa Rajkumar

Educational Technology I.I.T.Delhi 
presents

A Video Course on Programming Languages
by
Dr.S.Arun Kumar 
Deptt . of Comp.Sc. & Engg.
I.I.T. Delhi 

Lecture 2
Syntax

welcome to the second lecture if you were to look at let us just go briefly through what we did in the last lecture 
so as i said we are mainly concerned with what might be called high level programming languages of which i said there are three kinds 



imperative functional they are the most important and logic itself can be used as a language but our main concern is with this imperative and functional languages um 
they are also similar so in certain respects so imperative language is a what might be called state based languages where state updation is the main action um
whereas functional languages are really value based languages much closer to our mathematical languages in the notion of variables in functional languages is very much like the notion of variables in mathematics whereas the notion of the variables in the imperative languages is more like quantities in physics which can change over in time 
quantities like acceleration velocity um and um so 
so state based languages means that there is a state change along along let us say something like a trimaxes 
though unlike physics we are not talking of continuous time we are talking of discrete time in the case of functional languages the notion of the variable is really a variable in mathematics which means that a variable just is a name for a value and it cannot change in time during the execution of a program 

any way [02:24] so um the if you so let me just briefly look at so if you look at the history of languages most of the work on the high level languages is really concentrated on the imperative languages 



and there are hundreds and hundreds of programming languages so firstly it is impossible to study all of them ok and if you look at the history you will find that a large portion of the time during the fifties and sixties a large portion of time was concentrated on what might be called the basic features 
so which means these these represent the basic control structures the exploration of the basic control structures in the basic data structures in order to obtain clean readable programs efficiently implement able programs um efficient running programs and so on 
but later once these things were fixed in the seventies and eighties most of the exploration of programming languages was in terms of what might be called features 
like if you were to take modula it is most important feature it is just a extension of pascal most important feature is that of a module 
if you were to take Ada it combines the module features of modula and adds more features like concurrency as an important feature exception handling generics or polymorphism um
if you were to take um so similarly CLU is a module based language very much like modula but with a different syntax 
but they are all extensions of pascal in that in the sense the basic control structure remain the same and then you extend the language 
if you look at these the basic control structures in these languages could be different too they are not very similar except that these arrow mark denote the decendency in terms of similarity of even the basic control structures 
so from simula let us say um even though the small talk eighty control structures or syntax are different from that of simula 
the basic extensional feature comes from a new feature of simula which was extended and that was the notion of class or objects ok

so these [05:00] so if so what we mean by features are these kinds of features 
this is the language of sequential most of the languages in the early sixties were 



sequential whether they are concurrent whether they are modular whether they are distributed whether they are parallel whether they are object oriented and so on 
clear 

so [noise] so and nowadays biolarge their exploration is mostly in terms of new features what kind of new features and what i have listed as the various kinds of features is let us say the current state of art 
large amount of work is into trying to make them more efficient trying to make them more readable comprehend able and so on ok 



so um the basic functional languages also have this feature that the early functional languages where all an exploration of very basic data structures and controls and control structures then languages like ML CAML actually signify the addition of new features 
in fact the syntax of ML expressions and so on is very much is much closer to that of pascal than let us say of LISP 
but philosiscally it is a more LISP like language because it is a applicative or a functional language it is not a state based language and it goes far beyond LISP in the sense that there is a there are new features like the introduction of modules introduction of exceptional handling 
the introduction of very powerful data abstraction mechanisms and a type checking ok so LISP is LISP has no type checking at all right 
so let us look at in we will so we will first study the basic features of languages and so let us look at what constitutes um may be what are the issues in in some thing like language design 

if you [07:20] were to design a language what kinds of issues would you really have to study 
so once um one very major issue that the implementation that the language pascal has taught us is that it is a good idea it is a very good idea for a language to have a simple clear and a small set of unified unified primitives for expressing basically all your algorithms and data structures
one of the nicest thing about pascal or in general about what are know as algol sixty like languages is that most algorithms are written in in some crude variations of the dialect of pascal or algol system 
so the nice thing about pascal is that it is a small language easily learnable for example which is why most people are taught initially um and so one issue could be that 
you should start with a small language with a small set of primitive operations over which you can build yeah



and secondly the next issue would be that you should have an absolutely clear syntax there should be no ambiguity and you should be able to get highly readable programs 
it is very important um to have readability that means by readability it means that i have to be able to read the source code of the program like a book and and a very good reason for that is that no piece of software that you write is ever permanently fixed what hsppens is that 
well most pieces of software have bugs in them so bugs might be detected years and years after their software is been commissioned 
so what and years and years after means that there might there must be so there must be somebody else if a bug is detected who should be able to read the source code and be able to modify it and in order able to be read the source code he should be able to understand the algorithms of the source code contained 
so in fact efficiency and such consideration come much later readability is the most important thing because it includes maintainability of the software yeah 
so normally the normally the person who write the person or persons who have written this software are not likely to be present um to be to maintain the software 
so the software in general has to be maintained by somebody else so which means that the source code must be readable 
so that is the that is the first thing the second thing is that over the years the software actually has more and more users use their piece of software more and more users feel their need for its extension 
so you have to be able to extend the software may be by adding new features by adding some more conveniences what ever may be the reason 
so part of the maintainability of a piece of software is not just the detection and correction of bugs but also the extensibility of the software as years go by and more and more needs are felt it is necessary for somebody whose usually not the original programmer or the original team that wrote the software to be able to extend and for all that readability is most important yeah and secondly that’s the language should provide what is know as a support for abstraction 
the basic abstraction mechanisms you are already aware of the control abstractions or things like procedures functions in pascal [noise] loops loop statements there are various kinds of control abstractions 
there are also data abstractions like for example the most primitive kind of data abstraction that pascal provides are the record structures of course the arrays which almost all languages even the early languages have 
so arrays are one data abstraction that means you think of a whole set of a whole sequence of elements as a single unit and you try to as a single logical unit um 
records variant records and of course what what 
what has been felt in um later years is that you should have abstraction data abstraction which allows you not just the ability to take sets of data together as a single unit but also to operate on them as a single unit 
so combinations of operations and data abstractions in in a module basis ok or further abstractions like you might require i mean um for example languages like ML Ada provide the notion of a generic or polymorphism where you can use types as themselves as variables and change types and instantiate the same kinds of algorithms 
for example stacks it doesn’t matter whether you are talking of  a stack of integers a stack of characters a stack of reals a stack of um 
some complicated data element may be stack of some record of things or stacks of arrays of things 
the basic operation on stacks are like pop push checking for emptiness and so on they should all be available in one form and it should not be necessary for me to repeat the code depending on the type of the element right
so that is an abstraction where the basic element of the stack itself is a variable which can be instantiated to a different type each time and i use the same piece of code carefully written verified may be thoroughly tested and instantiate the types 
so that i get different kinds of stacks with the same kinds of operations right so the support for abstraction is an important modern language design issue and um other kinds of issues that have come up or which are becoming more and more reasonable is  [14:25]

one is that you should there should be able to you should be able to verify your programs so the language should also provide support for verification provability of programs not necessarily machine based provability but possibly hand based provability or a mixture or a user interactive provability of programs and most and something that was felt even in the sixties where a lot of time and effort was expended in the case of fortan and cobol compilers was portability ok 
nowadays so when i say portability what means what it means is that the language design should be such the language should be such that it is oriented towards an end user and it is not architecture or machine independent or machine specific 
simply because a certain machine as a certain kind of assembly instruction it does not mean that you make that available in the language other machines may not have that 
so you should um machine independence means that you should be able to provide as far as possible an abstract form which is not related to the machine ok




which uses only the basic instruction set [noise] which will be available in all machines if you ensure that you language is really architecture or machine independent 
in the sense that your main concerns have been with are with the users um convenience the abstractions required for the user and are not specific to particular machine instructions sets of particular architecture like you might have register based architectures or stack based architectures 
if if you can design the language in such a fashion that it is not architecture specific or machine specific then what it means is that i can move the entire language to another machine with a different architecture and with the minimum amount of effort 
there are certain archi certain machine specific details which still have to be changed when i move an entire language implementation from one machine to another or from one architecture to another but the whole idea of the language design or the design of its implementation should be that the amount of changes have to be made should be minimum 
so we will look at some reason for that so in addition and then there are things like you should be able to easily implement 
i mean you cannot compromise as everything at the alter of portability um ease of the implementation the availability of ready algorithms for implementing the language um should also i mean should be a consideration one of them 
i mean ease of the implementation was perhaps the most important reason um for this and the fact that it used very low level primitives perhaps the most important reason for the success of C the C language for example um 
and well efficiency is another important reason C C programs run very fast and they are very efficient um and something that some thing that if you are going 
if you have a language and you want it to be generally acceptable then what it should have is a clear definition of what its constructs do 
so that  if it has to be widely acceptable there might be many different implementers trying to implement it on various machines and only if there is a common clear syntax common clear semantics or the specification [18:45] of the effects of each language construct 
each construct in the language only then you can you can expect to get wide applicability ok so we will get to the notion of semantics later then 
of course there has to be i mean it has to be run time efficient by run time efficient i mean that the programs have to run efficiently 
this is the efficiency of the implementation which means very often it means compile time efficiency 
how fast can you compile programs written in the language whereas this runtime efficient is that it should have an excellent runtime support and the program should run as fast as the programs written in the language should run fast yeah
ease of maintenance here i am talking about the maintenance of programs as well as the maintenance of the language by an implementation maintenance of the implementation of the language 
there might be bugs in the language implementation and um [noise] [19:46]

well fast [19:48] compilation translation and support for extensibility which is in fact the most important reason why for example pascal is used as a basic support as a the language of pascal is used as the basic language from which you add onto which you add new features to get newer languages 



this is one controversial feature that is the support for subsets this used to something that most programming languages books used to specify that every language should support subsets of the language in the sense that it should be necessary for me to use only a smaller set of  operations or features of the language than is actually necessary and you should
by support for subsets what i am saying is it should be possible to take you should be able to divide up the language so that there is a small kernel and larger large sort of extensions ok 
so so that all programs written for the small kernel any way run on all machines regardless of the subset supported ok 
however the language of Ada for example the eighties has clearly specified that there should be no support for subsets and their reasons is that then it affects the portability of programs written in the language yeah 
so so support for subsets is a controversial thing which it is not at all clear whether it is desirable especially in the as in the case i mean the most important language for embedded systems 
you know real time things with systems that control sensors various kinds of hardware ballistic missiles and so on 
it affects it could affect their portability because you would have some feature which which is used in some in some implementation and then you move the program to another implementation which does not support that feature like your programs don’t run right 
so the portability of actually programs written in the language gets affected if you allow arbitrary subsets yeah [noise] ok
so if you look at all these features um and so finally what we can do is and then there are hundred and hundreds of programming languages it is impossible to study all of them what is more it is not necessary 
so what we would like to do is to divide up the study of programming languages into a few small parts so what we will do is we will look at [22:50]

so what is a theory of programming languages contain yeah so [noise] a general theory of programming languages is based on three things
what might be the most important thing is or the most basic thing is what is known as the syntax of the language ok
so a programming language is really like a very highly simplified natural language it has  a certain syntax right so which means that it has a certain what might be called the grammar certain things can occur only in certain ways 
you cannot you cannot arbitrarily take um you cannot arbitrarily form sentences of the language as i said a program written in that language is just a what might be called as the sentence of the language and in a natural language you take a sentence of a natural languageit has various parts 
so  for example in almost all languages all natural languages one thing that any full sentence should have is a predicate that is a it has a a syntactic category called predicates ok which in general may not be words a predicate could be a clause or a phrase um and so it might have a subject too in addition it might have a object 
so if you take a sentence in natural language so if i say run that is a complete sentence because it has a predicate 
no complete sentence in the natural language is without a predicate ok so run is a complete sentence it has a predicate optionally um it might have a subject may be also a object clause so and the subject clause is have to be of a grammatical form called they must be subject well subject phrases may be noun phrases 
which means they might have nouns qualified by object um adjectives may be an article and so on and so forth yeah
so what you can do is you can divide up any grammatically correct sentence in a natural language into firstly various clauses 
each clause may be into various phrases and all these phrases have certain grammatical properties yeah in very much a similar manner
in a greatly simplified form um what might called the parts of speech of a um of a program yeah  
in so every programming language has a certain grammar there are which specifies various parts of speech 
it has a certain what might be called vocabulary and it is possible to take a sentence of this programming language and parse it 
we will get into the meaning of these things more clearly later where the similarities with natural language 
after all a lot of the theory of the syntax was actually inspired by natural languages where the construction of artificial languages which did not have the which did not have a lot of problems in the natural language yeah um
the next thing is that is what might be called the semantics very often this semantics of a programming language is really specified by its reference manual 
so if you in your i mean in your study of pascal programming um one of the important references would be the iso standard pascal reference manual  by janson Edward ok 
so that reference manual really specifies for each syntactic entity of this of the language 
what is the effect to be expected by executing that syntactic entity so in other words what we are saying is for each language construct what are the meaning associated with it yeah
so the notion of meanings is something we have to look at unlike natural language the notion of meaning is something that can be specified um mathematically in a machine independent fashion
so when we are talking about this semantics of this programming language we are talking about a pure meaning associated with the language regardless of any machine on which the language is implemented 
in general we are talking about meanings in a abstract settings in the sense that you assume if you like for practical purposes that you have no restrictions on the word lengths you have no restrictions on memory 
you have no restrictions on computational power except that you can only do a finite number of operations at any instance right 
so you assume a sort of so the semantic the programming language itself can be thought of as a mathematical entity quite independent from all its implementations and in general when you think of it that way then what you are saying is 
you are thinking of some kind of an ideal machine which has no restrictions except one restriction that at any instant of time only a finite number of operations can be performed 
i mean you cannot do an infinite number of operations at a instant of time 
so if you consider such an ideal machine and um and then you are really looking at the programming language as a mathematical entity in some ideal environment ok and the meanings of that of the constructs of the language in that ideal environment form what might be called um actual reference manual 
so if you were to go through the reference manual of pascal let us say since that is you all have studied 
there are certain most of the reference manual is independent of any machine there are certain specific machine paragraphs or what are known as implementation dependent features but if you look at the language itself 
it is capable of looking at the language as an entity devoid of any machine yeah so most of the times

so in [30:13] general the semantics follow the syntax 
the syntax has a certain structure which will come to and the semantics so the syntax has 



got some what might be called some basic elements and some compound forming operations 
they are connectives compound um connective which allow you to form um compound that is the sentences from simpler once um 
so the meanings in general should be such that you gave the meanings of the basic elements and then you give the meanings of the connectives in terms of the basic elements 
so very often what it should be necessary is since a programming language is really a finitary object which allows you the construction of the infinite set of programs ok
it is not possible to unless you have this basic discipline that you express the effects of connectives in terms of the effect of the basic elements of the language 
it is not in general possible to predict the behavior of the language of a program written in the language unless you follow this discipline ok
so basic feature of any kind of semantics is that it should allow for the derivation of the meanings of an infinite number of programs which means the only way to derive the meaning of the program should be from the meanings of its finitary elements 
so you have certain basic elements from which complex elements are formed so the meaning of the complex element should be derivable in terms of the meanings of the basic elements and the meanings associated with the connectives which formed a complex element from the basic elements ok
so what it means is that semantics is going to b intimately related to the syntax the syntax is really a way a finitary way of specifying an infinite set of allowable objects ok
the infinite set of allowable objects are the programs of the language or the sentences of the language and the syntax gives you finitary mechanism for specifying all possible allowable programs very much like a set theory notation right 
the set builder notation which allows you to give a finitary specification of an infinitary set of an infinite set and so the only thing that is really analyzable for a arbitrary program is its structure in terms of its syntax 
the finitary specification so the meaning of the program has to be derived from there from its finitary specification as to be expressed in terms of its finitary specification yeah 
so lastly so this is a semantics of a language is in a sort of an ideal environment 
don’t worry about machine constraints 
don’t worry about architecture they are all 
we don’t want to worry about them because for one important reason i mean the programs have to be the programming language has to be portable ok
don’t worry about word lengths 
don’t worry about limits 
don’t worry about memory constraints assume infinite amount of memory available so then what happens is that 

you get [33:58] into what are known as pragmatic considerations yeah
once so most of these implementation dependant features are really pragmatics



for example the pascal reference manual does not tell you how to associate a disc file with a file variable in side the program 
that is one example of an implementation dependant feature which will vary depending upon the operating system interface you have yeah then there are various simple implementation um 
so the pragmatics firstly um firstly involves really all the algorithms that are going to be used for the implementation of the language 
all kinds of machine and architectural constraints for example this the MAXINT the maximum integer allowable in a pascal program is a typically implementation dependant feature because it really depends upon word length or byte length or um byte length or whether it uses two bytes for representing a integers and so on and so forth right
so the value of the MAXINT can very from machine to machine the amount of memory that is available for a program can vary whether it is a stack based machine or a register based machine um those things are implement um those things are implementation dependent features ok
so normally what we would do is even in our implementation in order to make the language portable we will separate out the basic algorithms of implementation from the architectural specific nature of the implementation when we do a 
when we read through a small compiler you will see this happening so there are certain basic algorithms which are really machine independent and then there are some machine dependant features the actual code
so then you have things like the os interface what is the nature of the input and output that is file based terminal based sensor based what ever 
signal based and the os interface also includes the file server how the language has to interact with the file saver um with how the language has to interact in general with the directory service of the machine and so on and so forth and lastly what 
what is to be done about errors and by errors i mean errors written by errors introduced by users in their programs 
so errors could be of a syntactic nature errors could be of runtime nature what is to be done about these errors 
as a blanket um there is a blanket policy could be just is just that you abort but you know that doesn’t help anybody in particular what is the nature of the error reporting
is there some error correction that can be done is there some way of recovering from errors 
so that as soon as the first error comes you just throw out the program no it is if you can at least you should be able to point out all the errors in the program or all possible things that are errors 
so that the user gets to know all the errors at one time it reduces the amount of compilation effort and similarly you cant do that at run time may be but at least there should be some decent error reporting mechanism some error handling mechanism 
so that is one thing but errors is a very [noise] dicey object it is very dicey policy and different languages have taken different attitudes 
different implementations take different attitudes um so so it is a very very pragmatic feature yeah 
so i will just briefly go through the notion of syntax and then may be i will stop so these are the three issues and it is better to study all three issues sort of separately 
the semantic and pragmatic issues will closely depend upon the syntax and it is preferable that they depend upon the syntax 
so let us look at what constitutes syntax yeah so 

a syntax [39:20] has to do with a form or a physical representation of possibly an abstract object yeah so if you look at numbers um 



numbers really are not very physical at least um the twentieth century attitude towards numbers is that they are a conception of the mind and they are not physical 
what they do have is a physical representation in the form of numerals ok
so what you write out and think of as a number is actually a numeral right so while you have various ways of representing the same number 
let us say the number one hundred and twenty six um so you can have what what is known as the positional representation which is what we normally use um and well this this is one hundred and twenty six written in hexadecimal and i hope it is correct yeah um
so you um so in the basic form all these three representations of the number one hundred and twenty six are really the same ok 
the roman representation differs from the theonagri representation in the sense that the characters used are different 
what might be called the basic alphabet for the positional representation of numbers is um is different in the two 
it is just that the character set is different um this the character set is also different it is a positional representation which uses a base the character said therefore is also different but that is incidental yeah
but in a in a basic forms all these are unified by the fact that they are all positional representations yeah
positional representations i hope everybody understands that um right you go in units tens hundreds 
here you go in units sixteen’s sixty four’s and so on right um then of course you have the roman numerals which is non positional which has well firstly it has a different alphabet 
you could represent the same um roman same number one hundred and twenty six with different character sets but there is something unifying about um about this 
there is some thing fundamental difference about this representation from this from any of this yeah so and what is it fundamentally different
if you disregard the change in character set what makes these two the same what makes these three the same and what makes these three different from these two ok
what make that what that do what makes these two classes different is the grammar of the numeral of the language used for representing them yeah 
in both these cases the grammar is exactly identical the character sets are different and by enlarge the grammar of all these three is the same except for the character sets 
but the grammar of this is different from the grammar of this in the sense the form of representation is fundamentally different
how you represent compound forms from simpler forms is different between the roman and Arabic case ok
so what is that grammar is what we have to study yeah so so let us look at the 
so let us look at this in a more general setting of the programming language so we might think of every programming language as containing of as having a vocabulary ok [43:08]

a vocabulary is well what you might call a complete dictionary of words of the language and a word of a language is formed from a character set from a fixed character set and



well you identify certain strings of characters as words as allowable words as part of the vocabulary of the language 
so a complete dictionary of the language is what constitutes that states vocabulary so if you look at i mean what i am saying is so so if you take languages 
for example natural languages like konkani or sindi what they have is different character sets and but the same collection of words ok
sindi for example is written by different people some people write in devanagri some people write it in the urdu script the Arabic script ok 
but the collection of the words is the same so a person who knows devanagri can communicate with the person who doesn’t know devanagri but knows the urdu script by speech because the words are the same but you cannot communicate by letter ok
so there is a certain fixed collection of words whose actual form might depend on the character set right um 
but given the words there are what are known as formation rules yeah so given a vocabulary there are ways of combining words of the language to form sentences of the language and there is a finite set of formation rules which are called 
the formation rules are called productions which allow you to generate all possible sentences in the language yeah
so let us quickly go through one example um so we will we will we will not worry too much about this character set because i think that s
so for a programming language for example the character set really depends upon the kind of codes you use nowadays most of the time we use ascii codes but then you know we have eight bit ascii’s and pcs and seven bit ascii’s on main frame 
the character sets are different there are all these kinds of differences ok but let us disregard them um
and let us just look at so let us just look at what just constitutes the a grammar so so i would say grammar 

grammar is [46:00] really a four tuple of objects ok where there is a set N which are called which is called the set of non terminals and this set of non terminals really 



specifies various kinds of grammatical categories of the language like you might say the parts of speech 
noun phrase verb phrase adjectival phrase noun clause subject clauses subject phrases object clauses predicates and so on ok
so this set N consists of the basic grammatical categories all these all these sets are finite ok then the terminal T is the set of what are known as terminal symbols or terminal words and T is the complete vocabulary of the language ok so
and P is the collection of formation rules or what are known as productions and S is what is called as the start symbol but S really is represents a grammatical category in N called as sentence yeah
so so so it so the basic element of the language is what constitutes a sentence right
so let me just quickly go through um ok 

so so [47:56] here is a simple grammar specifying Boolean expressions so there is a start symbol S 



every grammar should have a start symbol S and some grammatical categories the grammatical categories that i have chosen are A V and C which actually stand for an add Boolean expression or a or Boolean expression or a complement expression ok
the vocabulary of this language consists of all possible Boolean variables that we might take the two left and right parenthesis and the three connectors and not and or ok
these are the productions from the start symbol any Boolean variable is a Boolean expression that is 
so you take any b belonging to this set of Boolean variables that’s that one itself a Boolean expression 
so the sentence of this languages are Boolean expressions actually they are more than fully parenthesized Boolean expressions ok 
so any a sentence is either a complement of a Boolean expression or the or of the two boolean expression or the and of the two expressions 
an and clause if an and expression is one of the form which consists of two Boolean expressions enclosed in parenthesis and separated by the word and ok 
an or Boolean expression similarly is two Boolean expression enclosed in parenthesis and separated by an or and not is similarly this yeah 
so these productions are really replacement rules so whenever you find a S you can replace it either by a A or V or a C or one of the Boolean variables 
whenever you find an A you have to replace it by this there is no other way you can replace A by anything else similarly whenever you see a C you have to replace it by this and so here is a simple sentence generation

you start [50:17] from S and one of the possibility is that you can you can replace S by C ok whatever i am replacing i have circled in orange


 
so you can replace S by C 
C has to be replaced by something of this form by this and now i am replacing this S leaving everything else intact 
so i have chosen here to replace S by A and once i have replaced once i have got a A there the only possibility is to replace it by something of this form S and S 
i have chosen to replace this S rather than this S first and i have chosen it to replace it by a Boolean variable 
so let us assume that there are only two variables b one and b two and i proceed in this fashion and lastly i get a complete sentence of the language which consists of only the terminal symbols and this is a sentence of this other language generated by this grammar yeah

so we [51:30] talk of a language as being generated from a grammar as a set of all 
possible 



sentences that may be generated from the start symbol S 

important warnings [51:40] are that the set of non terminals and the set of terminal symbols are disjoint and a production is really a replacement 



it replaces a non terminal by a string consisting of terminals or non terminals yeah and sentence is just a string of terminal symbols generated from the start symbol yeah
i think i will stop here now um 





